"use strict";(self.webpackChunkteoria_das_artes_visuais=self.webpackChunkteoria_das_artes_visuais||[]).push([[896],{3778:(e,s,n)=>{n.r(s),n.d(s,{assets:()=>a,contentTitle:()=>l,default:()=>h,frontMatter:()=>r,metadata:()=>o,toc:()=>d});var i=n(4848),t=n(8453);const r={},l=void 0,o={id:"blender/meshes",title:"meshes",description:"Meshes",source:"@site/docs/05-blender/04-meshes.md",sourceDirName:"05-blender",slug:"/blender/meshes",permalink:"/docs/blender/meshes",draft:!1,unlisted:!1,editUrl:"https://github.com/tcarvi-engenheiro-eduardo-leal/teoria-das-artes-visuais/edit/main/tutorial/docs/05-blender/04-meshes.md",tags:[],version:"current",sidebarPosition:4,frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"User Interface",permalink:"/docs/blender/user-interface"},next:{title:"selecionar",permalink:"/docs/blender/selecionar"}},a={},d=[{value:"Meshes",id:"meshes",level:2}];function c(e){const s={a:"a",h2:"h2",li:"li",ol:"ol",ul:"ul",...(0,t.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(s.h2,{id:"meshes",children:"Meshes"}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsx)(s.li,{children:(0,i.jsx)(s.a,{href:"https://wiki.blender.org/wiki/Source/Objects/Mesh",children:"https://wiki.blender.org/wiki/Source/Objects/Mesh"})}),"\n",(0,i.jsxs)(s.li,{children:["Data Structures:","\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsxs)(s.li,{children:["Blender uses two main data structures for meshes:","\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsxs)(s.li,{children:["Mesh:","\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsx)(s.li,{children:"The main data structure associated with the ID_ME data-block type."}),"\n",(0,i.jsx)(s.li,{children:"Focuses on performance with many elements."}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(s.li,{children:["BMesh:","\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsx)(s.li,{children:"Edit mode data structure that prioritizes implementation of small topology-changing operations."}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(s.li,{children:"Meshes use data structures oriented around a struct of arrays paradigm."}),"\n",(0,i.jsx)(s.li,{children:"One idea behind that design is to decrease the amount of memory accessed in hot loops that generally only deal with a few data elements at a time."}),"\n",(0,i.jsx)(s.li,{children:"It also allows using generic algorithms that aren't necessarily only designed for mesh."}),"\n",(0,i.jsx)(s.li,{children:"For more background on the SoA paradigm in meshes, see the design task."}),"\n",(0,i.jsxs)(s.li,{children:["Lazily Calculated Caches","\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsx)(s.li,{children:"In order to defer calculation of some runtime data until it's actually needed without duplicating work, there are a few lazily calculated caches stored on meshes."}),"\n",(0,i.jsxs)(s.li,{children:["Some examples are:","\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsx)(s.li,{children:"Bounds: (BKE_mesh_minmax) The min and max position of the mesh"}),"\n",(0,i.jsx)(s.li,{children:"Vertex Normals: (Mesh.vert_normals()) The normal of every vertex. The same as the surrounding face normals mixed together, weighted by the corner angle."}),"\n",(0,i.jsx)(s.li,{children:"Face Normals: (Mesh.poly_normals()) The normal direction of each face according to its winding direction."}),"\n",(0,i.jsx)(s.li,{children:"Loose Edges: (Mesh.loose_edges()) Whether each edge is loose, and the total number of loose edges."}),"\n",(0,i.jsx)(s.li,{children:"When a mesh is changed, these caches need to be removed or tagged dirty. Generally this is possible with functions like BKE_mesh_tag_coords_changed."}),"\n",(0,i.jsx)(s.li,{children:"Meshes support all generic attribute types."}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(s.li,{children:["Elements of a Mesh Structure:","\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsx)(s.li,{children:"edges (linhas de limite)"}),"\n",(0,i.jsx)(s.li,{children:"faces"}),"\n",(0,i.jsx)(s.li,{children:"vertex"}),"\n",(0,i.jsx)(s.li,{children:"loops"}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(s.li,{children:["As a best practice, all manipulation of a mesh structure should be done using Euler Operators.","\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsx)(s.li,{children:"This would be beneficial because the Euler functions would benefit from more extensive testing, becoming very stable, and thus increasing the stability of the BMesh tools that rely on them."}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(s.li,{children:"However, currently many of the BMesh operators edit mesh structure directly instead of using these Euler Operators.  It should be a post-merge goal to convert all BMesh operators to use Euler functions, potentially adding extra Euler functions if necessary."}),"\n",(0,i.jsx)(s.li,{children:"As part of the original design, BMesh would be capable of handling multiple boundaries for a single face, which would allow for holes in faces. This has become a non-goal of the first BMesh feature merge, as we have chosen instead to stabilize the existing BMesh feature set to prepare for the first BMesh merge."}),"\n",(0,i.jsxs)(s.li,{children:["\n",(0,i.jsxs)(s.ol,{children:["\n",(0,i.jsx)(s.li,{children:"Weiler, K.J. : The Radial Edge Structure: A Topological Representation for Non-Manifold Geometric Modeling. in Geometric Modeling for CAD Applications, Springer Verlag, May 1986."}),"\n"]}),"\n"]}),"\n"]})]})}function h(e={}){const{wrapper:s}={...(0,t.R)(),...e.components};return s?(0,i.jsx)(s,{...e,children:(0,i.jsx)(c,{...e})}):c(e)}},8453:(e,s,n)=>{n.d(s,{R:()=>l,x:()=>o});var i=n(6540);const t={},r=i.createContext(t);function l(e){const s=i.useContext(r);return i.useMemo(function(){return"function"==typeof e?e(s):{...s,...e}},[s,e])}function o(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:l(e.components),i.createElement(r.Provider,{value:s},e.children)}}}]);