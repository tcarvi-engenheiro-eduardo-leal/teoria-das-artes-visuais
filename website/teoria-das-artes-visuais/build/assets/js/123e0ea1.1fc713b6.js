"use strict";(self.webpackChunkteoria_das_artes_visuais=self.webpackChunkteoria_das_artes_visuais||[]).push([[1945],{6585:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>i,default:()=>h,frontMatter:()=>s,metadata:()=>o,toc:()=>c});var r=t(4848),a=t(8453);const s={},i="Transformation",o={id:"blender/transformation",title:"Transformation",description:"Blender's transformation",source:"@site/docs/05-blender/03-transformation.md",sourceDirName:"05-blender",slug:"/blender/transformation",permalink:"/docs/blender/transformation",draft:!1,unlisted:!1,editUrl:"https://github.com/tcarvi-engenheiro-eduardo-leal/teoria-das-artes-visuais/edit/main/tutorial/docs/05-blender/03-transformation.md",tags:[],version:"current",sidebarPosition:3,frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Navegar:",permalink:"/docs/blender/navegar"},next:{title:"User Interface",permalink:"/docs/blender/user-interface"}},l={},c=[{value:"Blender&#39;s transformation",id:"blenders-transformation",level:2},{value:"Basic transformations:",id:"basic-transformations",level:3},{value:"Advanced transformations:",id:"advanced-transformations",level:3},{value:"General structure for transformation",id:"general-structure-for-transformation",level:3},{value:"Call Flow",id:"call-flow",level:3}];function d(e){const n={blockquote:"blockquote",em:"em",h1:"h1",h2:"h2",h3:"h3",li:"li",p:"p",strong:"strong",ul:"ul",...(0,a.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.h1,{id:"transformation",children:"Transformation"}),"\n",(0,r.jsx)(n.h2,{id:"blenders-transformation",children:"Blender's transformation"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["An important concept of ",(0,r.jsx)(n.em,{children:(0,r.jsx)(n.strong,{children:"Blender Arquitecture"})}),"."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.em,{children:(0,r.jsx)(n.strong,{children:"Blender's transformation engine"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Based on the ",(0,r.jsx)(n.em,{children:(0,r.jsx)(n.strong,{children:"principle of generality"})}),"."]}),"\n"]}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsxs)(n.p,{children:["Instead of working on specific data types, transformation occurs on ",(0,r.jsx)(n.em,{children:(0,r.jsx)(n.strong,{children:"transform-specific abstract data structures"})})," that hold all the information needed for each specific transformation to do its job on all the ",(0,r.jsx)(n.em,{children:"Blender Data Types"})," that would support it."]}),"\n"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"So we have a generic structure for Move, Rotate and Scale, for example."}),"\n"]}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsx)(n.p,{children:"Em resumo: Temos uma estrutura gen\xe9rica para transformation. Esta estrutura pode ser usada por todos os data types de objetos do Blender. Mas um objeto tem  que suportar requisitos definidos pela estrutura gen\xe9rica para pode usar tal estrutura gen\xe9rica de transform."}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.li,{children:"Transformations refer to a number of operations that can be performed on a selected Object or Mesh. Operations that alter the position or characteristics of the selected object."}),"\n",(0,r.jsx)(n.li,{children:"Each object can be moved, rotated and scaled in Object Mode. However, not all of these transformations have an effect on all objects. For example, scaling a camera has no effect on the render dimensions."}),"\n",(0,r.jsxs)(n.li,{children:["Transform controls","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Transform controls can be used to modify and control the effects of the available transformations."}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["The transform constraint system is also generic: axis selection and basic spacial adjustment (correction for viewport and perspective) functions are defined once, each transformation function has to define how to apply it from the axis definitions.","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Same for numerical input (which supports N-axis input)."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"basic-transformations",children:"Basic transformations:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Move"}),"\n",(0,r.jsx)(n.li,{children:"Rotate"}),"\n",(0,r.jsx)(n.li,{children:"Scale"}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"advanced-transformations",children:"Advanced transformations:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Move/Scale Texture Space tool","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"It transforms the Texture Space of the object"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"general-structure-for-transformation",children:"General structure for transformation"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Important structures are all defined in ",(0,r.jsx)(n.em,{children:(0,r.jsx)(n.strong,{children:"source/blender/include/transform.h"})}),".","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"TransInfo"})," : Represents the transform engine. All global transformation flags and settings are stored in here. This structure is passed to each transform function call."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"TransData"})," : Represents a single transformation unit (a vertex, a CV, an object, ...)"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"TransDataExtension"})," : Holds additional information tied to TransData units (in the case of objects, this holds rotation and size information)"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"TransData2D"})," : Represents 2D Transformation units. These are used when flushing the transformation back to the 2D data, the actual transformations are done on TransData."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"NumInput"})," : Contains data needed by the Numerical input system (pretty much standalone)"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"TransSnap"})," : Contains data needed by the snapping system"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"call-flow",children:"Call Flow"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.em,{children:(0,r.jsx)(n.strong,{children:"Public interface (calls) to the transformation engine"})})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Defined in ",(0,r.jsx)(n.strong,{children:"source/blender/include/BIF_transform.h"}),"."]}),"\n",(0,r.jsxs)(n.li,{children:["It is kept purposefully ",(0,r.jsx)(n.strong,{children:"very simple"}),"."]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"The principal calls are initTransform(mode, context) which sets up the engine (data conversion, center and proportional editing (PET) calculations, transformation specific setup, ...) and Transform() which runs the actual transformation."}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"For the initialization call, mode corresponds to the transformation to execute and context refers to specific restrictions that can be applied to the transformation or that might precise on which data it needs to act if the global Blender context isn't clear enough. (constants for context flags and modes are also defined in this header)"}),"\n",(0,r.jsx)(n.p,{children:"The same pair of init/action functions exists for the manipulator (initManipulator and ManipulatorTransform) with the difference that the init function doesn't have a context argument (for lack of use, it might be added later if it is needed)."}),"\n",(0,r.jsx)(n.p,{children:"Drawing callbacks are defined for the manipulators, the PET circle of influence, the constraints guidelines and snapping target."}),"\n",(0,r.jsx)(n.p,{children:"Setup calls for the constraints system exists and must be called after the transform initialization call and, obviously, before the action call."}),"\n",(0,r.jsx)(n.p,{children:"Inner Workings\nHere's a quick overview of the inner call flow when public calls are received."}),"\n",(0,r.jsx)(n.p,{children:'Initialization\nGlobal initialization: initial mouse position, 3D view orientation save, global flags cleared\nPer transform mode flags setup: setup restrictions to numinput and constraints if needed\nTransData creation: depending on the Blender context, specific data is extracted from selection and converted to TransData for later manipulation.\nSelect what data type to convert\nExtract all or only selected data (depending on PET tool)\nConvert to TransData: This involves saving initial value for location and other specific properties (tilt for curves), creating TransDataExtension for data types that need it.\nInitialize Snapping Engine\nCalculate PET factors per TransData units if needed\nCalculate transformation Center depending on the center mode selected by the user\nPer transform mode initialization: this involves setting the function pointer corresponding to the actual transformation mode that will be applied, setting up "gears" step values (Ctrl / Shift), numerical input restrictions and other specific values\nMain Action Loop\nThis is basically a loop polling for UI events, calling the transform mode functions and doing cleanups once everything is done'}),"\n",(0,r.jsx)(n.p,{children:"Transformation loop\nCheck mouse position, if it moved, raise the redraw flag\nIf redraw flag is raised, call the transform mode function\nPoll for event, call the events treatment functions for each: that treatment function will dispatch events to the numerical input and snapping system for further treatment after trying to act on events itself\nIf state is CANCEL, roll back transformation using saved information in TransData and TransDataExtension (when present)\nFree transformation data structures\nSpecial post transform Blender updates (base flags, keyframe inserts, Actions insert, ...)\nPush undo if needed\nTransform Mode function\nThese are usually pretty simple. From the saved mouse pointer data, derive a transformation vector/factor/angle, loop on all TransData units and apply it. Here's a typical implementation (ToSphere). Others might be more or less complex. Steps in bold are rather mandatory."}),"\n",(0,r.jsx)(n.p,{children:'Use a generic input method to derive motion (InputHorizontalRatio)\nSnap value to the "grid/gears" steps\nApply numerical input\nCreate output string for header\nApply transformation to all TransData units\nrecalcData : Flush updates to Blender data when needed\nheaderPrint : Send text to the header\nviewRedrawForce : Send redraw events to the proper screen area'})]})}function h(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>i,x:()=>o});var r=t(6540);const a={},s=r.createContext(a);function i(e){const n=r.useContext(s);return r.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:i(e.components),r.createElement(s.Provider,{value:n},e.children)}}}]);